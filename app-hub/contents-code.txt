

==============================

PATH: apps/controller/program/index.ts

import type { Program } from 'algebraic-fx'
import type { TVEnv } from './env'
import type { TVModel, TVMsg } from './types'

import { init } from './init'
import { update } from './update'
import { subs } from './subs'
import { view } from './view'

export const program: Program<TVModel, TVMsg, TVEnv> = {
  init,
  update,
  subs,
  view
}



==============================

PATH: apps/controller/program/update.ts

import type { Payload } from '@shared/types'
import type { Dispatch } from 'algebraic-fx'
import type { NetworkMsg } from './network'
import * as Network from './network'
import { splitRoute } from '@shared/utils'
import { MessageDomain } from '@shared/types'
import { send } from './network'
import { program as Calibration } from './calibration'
import { program as Lobby } from './lobby'
import { routeByDomain } from './router'

export const update = (
  payload: Payload | NetworkMsg | { type: 'SELECT_TV'; session: string },
  model: Model,
  dispatch: Dispatch
) => {
  console.log(payload)
  // ---- NETWORK CONTROL (THIS WAS MISSING) ----
  if (
    payload.type === 'Enable' ||
    payload.type === 'Connected' ||
    payload.type === 'Disconnected'
  ) {
    const next = Network.update(payload as NetworkMsg, model.network)
    return {
      model: { ...model, network: next.model },
      effects: next.effects
    }
  }

  if (payload.type === 'SELECT_TV') {
    send({
      type: 'NETWORK.REGISTER',
      msg: {
        role: 'CONTROLLER',
        id: model.name,
        session: payload.msg.session
      },
      t: Date.now()
    })

    return {
      model: { ...model, session: payload.msg.session },
      effects: []
    }
  }
  // DOMAIN ROUTING (Phase 3)
  return routeByDomain(payload, model, {
    [MessageDomain.NETWORK]: (p, m) => {
      if (p.type === 'ACK') {
        dispatch({ type: `CALIBRATION.ENABLE_MOTION` })
        model.screen = 'menu'
      }

      return { model, effects: [] }
    },

    [MessageDomain.LOBBY]: (p, m) => {
      const r = Lobby.update(p, m.lobby, dispatch)
      return { model: { ...m, lobby: r.model }, effects: r.effects }
    },

    [MessageDomain.CALIBRATION]: (p, m) => {
      const r = Calibration.update(p, m.calibration, dispatch, model)
      return {
        model: { ...m, calibration: r.model },
        effects: r.effects
      }
    }
  })

  return { model, effects: [] }
}



==============================

PATH: apps/controller/program/subs.ts

import * as Network from './network'
import { subs as calibrationSubs } from './calibration/subs'
import type { Subscription } from 'algebraic-fx'
import type { ControllerEnv } from './env'
import type { Model, Msg } from './types'

export const subs = (model: Model): Subscription<ControllerEnv, Msg>[] => {
  return [...Network.subs(model.network), ...calibrationSubs(model.calibration)]
}



==============================

PATH: apps/controller/program/calibration/index.ts

import type { Program } from 'algebraic-fx'
import type { Model, Msg } from './types.js'
import { init } from './init.js'
import { update } from './update.js'
import { view } from './view.js'
import { subs } from './subs.js'

export const program: Program<Model, Msg> = {
  init,
  update,
  view,
  subs
}



==============================

PATH: apps/controller/program/calibration/subs.ts

import { sub } from 'algebraic-fx'
import { Motion } from 'capacitor-native-motion'
import type { Msg } from './types'
import type { ControllerEnv } from '../env'

export const subs = (model) => (model.enabled ? [motionSub()] : [])
const motionSub = () =>
  sub<ControllerEnv, Msg>('calibration:motion', (_env, dispatch) => {
    let remove: (() => void) | undefined

    Motion.start({ hz: 60 })
      .then(() =>
        Motion.addListener(
          'motion',
          ({ quaternion, gravity, rotationRate, timestamp }) => {
            dispatch({
              type: 'CALIBRATION.MOTION_EVENT',
              msg: { quaternion, gravity, rotation: rotationRate },
              t: timestamp
            })
          }
        )
      )
      .then((listener) => {
        remove = listener.remove
      })
      .catch((e) => console.error('[motionSub] failed', e))

    return () => {
      remove?.()
      Motion.stop()
    }
  })



==============================

PATH: apps/controller/program/calibration/update.ts

import type { Dispatch, RawEffect } from 'algebraic-fx'
import { send } from '../network/'
import type { Model, Msg } from './types'

export const update = (
  msg: Msg,
  model: Model,
  dispatch: Dispatch,
  ctx: Model
) => {
  switch (msg.type) {
    case 'ENABLE_MOTION':
      let m = model
      m.enabled = true
      return { model: m, effects: [] }

    case 'MOTION_EVENT': {
      console.log('motion', msg)
      const { quaternion, gravity, rotation, timestamp } = msg
      const next: Model = { ...model, quaternion, gravity, rotation }
      // const emit: RawEffect<any, any> = {
      // run: () => {
      send({
        type: 'CALIBRATION.MOTION_UPDATE',
        msg: { ...msg, session: ctx.session },
        t: Date.now()
      })
      // }
      // }

      return { model: next, effects: [] }
    }

    default:
      return { model, effects: [] }
  }
}



==============================

PATH: apps/controller/program/calibration/init.ts

import { IO } from 'algebraic-fx'
import type { Model } from './types.js'

export const init = IO.IO(() => ({
  model: {
    enabled: false,
    quaternion: [0, 0, 0, 0],
    gravity: [0, 0, 0],
    rotation: [0, 0, 0],
    timestamp: 0
  } as Model,
  effects: []
}))



==============================

PATH: apps/tv/program/update.ts

import type { RawEffect, Dispatch } from 'algebraic-fx'
import { MessageType, WordPondMsg, type Payload } from '@shared/types'
import type { WireMsg } from '@shared/protocol'
import type { TVEnv } from './env'
import type { TVModel, TVContext, TVMsg } from './types'
import * as Network from './network'
import { splitRoute } from '@shared/utils'
import { MessageDomain } from '@shared/types'
import { orientationToXY } from './effects'

import { program as Lobby } from './lobby'
import { program as Menu } from './menu'
import { program as Calibration } from './calibration'
import { program as Spray } from './spray-can'
import { program as WordPond } from './word-pond'
import { program as PacMan } from './pac-man'
import { program as Driving } from './driving'

/* -------------------------------------------------- */
/* helpers                                            */
/* -------------------------------------------------- */

const dispatchEffect = (
  msg: TVMsg,
  dispatch: Dispatch
): RawEffect<TVEnv, TVMsg> => ({
  run: (_env) => dispatch(msg)
})

const wireToPayload = (wire: WireMsg): Payload => ({
  type: wire.type as any,
  msg: wire.msg as any
})

const makeCtx = (model: TVModel): TVContext => ({
  session: model.session,
  screenW: model.screenW,
  screenH: model.screenH,
  controllers: model.controllers,
  actions: model.actions,
  players: model.players
})

/* -------------------------------------------------- */
/* update                                             */
/* -------------------------------------------------- */

export const update = (msg: TVMsg, model: TVModel, dispatch: Dispatch) => {
  console.log(msg, model)
  /* ---------- network wrapper ---------- */

  if (msg.type === 'Network') {
    const net = msg.msg

    if (net.type === 'Inbound') {
      return {
        model,
        effects: [dispatchEffect(wireToPayload(net.msg), dispatch)]
      }
    }

    const next = Network.update(net, model.network)
    return {
      model: { ...model, network: next.model },
      effects: next.effects
    }
  }

  if (msg.type === 'Shutdown') {
    return {
      model: { ...model, network: { status: 'off' } },
      effects: []
    }
  }

  /* ---------- payload ---------- */

  const payload = msg as Payload
  const ctx = makeCtx(model)

  const { domain } = splitRoute(payload.type)

  /* ---------- TV lobby routing ---------- */

  if (domain === MessageDomain.LOBBY) {
    const r = Lobby.update(payload, model.lobby)
    return {
      model: { ...model, lobby: r.model },
      effects: r.effects
    }
  }

  /* ---------- Calibration routing (GAME domain) ---------- */

  if (domain === MessageDomain.GAME && model.calibration) {
    const r = Calibration.update(payload, model.calibration, ctx)
    return {
      model: { ...model, calibration: r.model },
      effects: r.effects
    }
  }

  /* ---------- legacy root handling (unchanged) ---------- */

  switch (payload.type) {
    case MessageType.RELAY_HELLO:
      return { model, effects: [] }

    case MessageType.NAVIGATE: {
      const screen = payload.msg.screen as TVModel['screen']
      return {
        model: { ...model, screen },
        effects: []
      }
    }

    case 'ACTIONS_REGISTERED':
      return {
        model: { ...model, actions: payload.msg.actions || [] },
        effects: []
      }

    case MessageType.PLAYER_JOINED: {
      const players = [
        ...model.players,
        {
          id: payload.msg.id || '',
          name: payload.msg.name || 'Player',
          slot: payload.msg.slot ?? model.players.length
        }
      ]

      const screen: TVModel['screen'] =
        players.length === 1 ? 'menu' : model.screen

      return {
        model: { ...model, players, screen },
        effects: []
      }
    }

    case 'RESIZE':
      return {
        model: {
          ...model,
          screenW: payload.msg.width,
          screenH: payload.msg.height
        },
        effects: []
      }

    case MessageType.SPRAY_POINT:
    case WordPondMsg.NET_UPDATE:
    case WordPondMsg.SHAKE: {
      if (!model.wordpond) return { model, effects: [] }
      const r = WordPond.update(payload, model.wordpond, ctx)
      return { model: { ...model, wordpond: r.model }, effects: r.effects }
    }

    default:
      return { model, effects: [] }
  }
}

